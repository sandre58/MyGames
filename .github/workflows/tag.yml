name: Tag

on:
  workflow_dispatch:
    inputs:
      project:
        description: "Project name to release or empty for all"
        required: false
        default: ""
        type: choice
        options:
          - All
          - MyGames.Core
          - MyGames.Chess
          - MyGames.Chess.Console
          - MyGames.Connect4
          - MyGames.Connect4.Console
          - MyGames.Connect4.Wpf
      version:
        description: "Explicit version (e.g., 1.2.3) or empty for auto"
        required: false
        default: ""
      dry_run:
        description: "DRY_RUN mode (check to simulate without tagging)"
        required: false
        default: false
        type: boolean

jobs:
  discover-projects:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-projects.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute dependencies graph
        id: compute-dependencies
        run: |

          # Dynamically build the dependency map
          declare -A DEPENDENCIES

          for csproj in $(find src/* -name "*.csproj"); do
            PROJECT_NAME=$(basename "$csproj" .csproj)

            # Retrieve all project references
            REFS=$(grep -oP '<ProjectReference Include="\K[^"]+' "$csproj" | sed 's|.*/\([^/]*\)\.csproj|\1|')

            if [ -n "$REFS" ]; then
              DEPENDENCIES["$PROJECT_NAME"]="$REFS"
            fi
          done

          echo "Dependencies discovered:"
          for PROJ in "${!DEPENDENCIES[@]}"; do
            echo " - $PROJ depends on ${DEPENDENCIES[$PROJ]}"
          done

          echo "dependencies=$DEPENDENCIES" >> $GITHUB_OUTPUT

      - name: Discover projects
        id: set-projects
        run: |

          PROJECT_INPUT="${{ inputs.project }}"

          # List of projects to check
          if [ -n "$PROJECT_INPUT" ] && [ "$PROJECT_INPUT" != "All" ]; then
            PROJECT_LIST=( "$PROJECT_INPUT" )
          else
            PROJECT_LIST=()
            for project_dir in src/*/*/; do
              if [ -d "$project_dir" ]; then
                PROJECT_LIST+=( "$(basename "$project_dir")" )
              fi
            done
          fi

          CHANGED=()

          # Check for conventional commits since the last tag
          for PROJECT_NAME in "${PROJECT_LIST[@]}"; do
            for project_dir in src/*/$PROJECT_NAME/; do
              if [ -d "$project_dir" ]; then
                LAST_TAG=$(git tag --list "$PROJECT_NAME-v*" --sort=-v:refname | head -n 1)
                if [ -n "$LAST_TAG" ]; then
                  RANGE="$LAST_TAG..HEAD"
                else
                  RANGE="HEAD"
                fi

                COMMIT_COUNT=$(git log $RANGE --pretty=format:"%H" \
                  -- "$project_dir" \
                  --grep="^feat:" \
                  --grep="^fix:" \
                  --grep="^chore:" \
                  --grep="^docs:" \
                  --grep="^refactor:" \
                  --grep="^perf:" \
                  --grep="^test:" | wc -l)

                if [ "$COMMIT_COUNT" -gt 0 ]; then
                  echo "Project $PROJECT_NAME has Conventional Commits → will be tagged."
                  PROJECTS_TO_TAG="${PROJECTS_TO_TAG}{\"project\":\"$PROJECT_NAME\"},"
                else
                  echo "No Conventional Commits in $PROJECT_NAME → skipping."
                fi
              fi
            done
          done

          # Propagate to dependents
          IMPACTED=( "${CHANGED[@]}" )

          function add_dependents() {
            local PROJ="$1"
            for CANDIDATE in "${!DEPENDENCIES[@]}"; do
              for DEP in ${DEPENDENCIES[$CANDIDATE]}; do
                if [ "$DEP" == "$PROJ" ]; then
                  if [[ ! " ${IMPACTED[*]} " =~ " ${CANDIDATE} " ]]; then
                    echo "$CANDIDATE depends on $DEP → mark as changed"
                    IMPACTED+=( "$CANDIDATE" )
                    add_dependents "$CANDIDATE"
                  fi
                fi
              done
            done
          }

          for PROJ in "${CHANGED[@]}"; do
            add_dependents "$PROJ"
          done

          # Générer JSON pour la matrice
          PROJECTS_TO_TAG="["
          for PROJ in "${IMPACTED[@]}"; do
            PROJECTS_TO_TAG="${PROJECTS_TO_TAG}{\"project\":\"$PROJ\"},"
          done
          PROJECTS_TO_TAG="[${PROJECTS_TO_TAG%,}]"

          echo "Final matrix => $PROJECTS_TO_TAG"
          echo "matrix=$PROJECTS_TO_TAG" >> $GITHUB_OUTPUT

  tag-project:
    runs-on: ubuntu-latest
    needs: [discover-projects]
    if: needs.discover-projects.outputs.matrix != '[]'
    strategy:
      matrix:
        include: ${{ fromJson(needs.discover-projects.outputs.matrix) }}
    steps:

      - name: Setup Node.js (for semantic-release)
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install semantic-release
        run: npm install -g semantic-release @semantic-release/commit-analyzer @semantic-release/release-notes-generator

      - name: Calculate version with semantic-release
        id: calc-version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PROJECT="${{ matrix.project }}"
          echo "Calculating version for $PROJECT..."
          cd "src/*/$PROJECT/"
          VERSION=$(semantic-release --dry-run | grep -oP 'next release version is \K[0-9]+\.[0-9]+\.[0-9]+')
          echo "Calculated version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create and push tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PROJECT="${{ matrix.project }}"
          VERSION="${{ steps.calc-version.outputs.version }}"
          DRY_RUN="${{ inputs.dry_run }}"
          
          echo "Creating tag $PROJECT-v$VERSION"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          # Create and push the tag
          git tag "$PROJECT-v$VERSION" -m "Release $PROJECT v$VERSION"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "[DRY_RUN] Tag $PROJECT-v$VERSION would be pushed."
          else
            git push origin "$PROJECT-v$VERSION"
            echo "✅ Successfully tagged $PROJECT-v$VERSION"
          fi
